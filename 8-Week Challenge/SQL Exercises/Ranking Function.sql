CREATE TABLE EMPLOYEE
(
	EMP_ID INTEGER,
    EMP_NAME VARCHAR(32),
    DEPT_NAME varchar(32),
    SALARY INTEGER
);

SELECT * FROM EMPLOYEE;

INSERT INTO EMPLOYEE
(EMP_ID, EMP_NAME, DEPT_NAME, SALARY)
VALUES
(101, 'Mohan', 'Admin', 4000),
(102, 'Rajkumar', 'HR', 3000),
(103, 'Akbar', 'IT', 4000),
(104, 'Dorvin', 'Finance', 6500),
(105, 'Rohit', 'HR', 3000),
(106, 'Rajesh',  'Finance', 5000),
(107, 'Preet', 'HR', 7000),
(108, 'Maryam', 'Admin', 4000),
(109, 'Sanjay', 'IT', 6500),
(110, 'Vasudha', 'IT', 7000),
(111, 'Melinda', 'IT', 8000),
(112, 'Komal', 'IT', 10000),
(113, 'Gautham', 'Admin', 2000),
(114, 'Manisha', 'HR', 3000),
(115, 'Chandni', 'IT', 4500),
(116, 'Satya', 'Finance', 6500),
(117, 'Adarsh', 'HR', 3500),
(118, 'Tejaswi', 'Finance', 5500),
(119, 'Cory', 'HR', 8000),
(120, 'Monica', 'Admin', 5000),
(121, 'Rosalin', 'IT', 6000),
(122, 'Ibrahim', 'IT', 8000),
(123, 'Vikram', 'IT', 8000),
(124, 'Dheeraj', 'IT', 11000);

# MAX SALARY OF EMPLOYEE:
SELECT
MAX(SALARY) AS MAXIMUM_SALARY, DEPT_NAME
FROM
EMPLOYEE
GROUP BY
DEPT_NAME;

#--> WINDIW FUNCTION
SELECT
*, MAX(SALARY) OVER(PARTITION BY DEPT_NAME) AS MAX_SALARY_OF_THE_DEPT
FROM EMPLOYEE E; 

#--> Row Number, Rank, Dense Rank, Lead and Lag
SELECT
*, ROW_NUMBER() OVER(PARTITION BY DEPT_NAME) AS ROW_NUM
FROM
EMPLOYEE;

 #--> FETCH FIRST " EMPLOYEE JOINING EACH DEPARTMENT.
SELECT * FROM(
SELECT
*, ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS ROW_NUM
FROM
EMPLOYEE
) X
WHERE
X.ROW_NUM < 3;

# --> SELECT THE TOP 3 EMPLOYEES IN EACH DEPARTMENT EARNING THE MEX SALARY
SELECT * FROM 
(
SELECT
*, ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RANKING
FROM
EMPLOYEE) X
WHERE X.RANKING < 4;

#--> DENSE RANK
SELECT
*, ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS ROW_NUM
FROM
EMPLOYEE;

##NOTE -> ROW_NUMBER() - CONTINOUS NUMBERING
##NOTE -> RANK() - SKIPS COUNTING (SAME RANK TO SIMILARS)
##NOTE -> DENSE_RANK - DOES NOT SKIP COUNTS(SAME RANK TO SIMILARS)
##EXAMPLE IS GIVEN FOR ALL THREE COMPARISION--

SELECT
*,
ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS ROW_NUM,
RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RANKING,
DENSE_RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS DENSE_RANKING
FROM
EMPLOYEE;

#--> DENSE_RANK()
SELECT
*, RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RANKING,
DENSE_RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS DENSE_RANKING
FROM
EMPLOYEE;

##FETCH A QUERRY TO DISPLAY IF THE SALARY OF AN EMPLOYEE IS HIGHER, LOWER OR EQUAL TO THE PREVIOUS EMPLOYEE.(PREVIOUS DATA WILL BE RETURNED)

SELECT
*, LAG(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PREV_EMP_SALARY
FROM
EMPLOYEE;

#--> LEAD DOES THE SAME BUT GIVES THE NEXT DATA.
SELECT
*, LEAD(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PREV_EMP_SALARY
FROM
EMPLOYEE;

#--> CASE SYNTAX: IF THE PREVIOUS SALARY IS HIGH; SHOW HIGH OTHERWISE LOW OR EQUAL.
SELECT
*, LAG(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PREVIOUS_EMP_SALARY,
CASE WHEN SALARY > LAG(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) THEN 'HIGHER'
	 WHEN SALARY < LAG(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) THEN 'LOWER'
     WHEN SALARY = LAG(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) THEN 'EQUAL'
     END SALARY_SUMMARY
FROM
EMPLOYEE;